"use strict";(self.webpackChunkgoji_js_org=self.webpackChunkgoji_js_org||[]).push([[719],{3289:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var r=t(8427),o=t(4397),i=(t(2784),t(876)),a=["components"],s={sidebar_position:5},c="Refs",l={unversionedId:"guide/ref",id:"guide/ref",title:"Refs",description:"Purpose",source:"@site/docs/guide/ref.md",sourceDirName:"guide",slug:"/guide/ref",permalink:"/docs/guide/ref",editUrl:"https://github.com/airbnb/goji-js/tree/main/packages/goji.js.org/docs/guide/ref.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Lifecycle",permalink:"/docs/guide/lifecycle"},next:{title:"Cross-Platform",permalink:"/docs/guide/cross-platform"}},p={},u=[{value:"Purpose",id:"purpose",level:2},{value:"Refs",id:"refs-1",level:2},{value:"<code>useRenderedEffect</code>",id:"userenderedeffect",level:2},{value:"Usage",id:"usage",level:2}],d={toc:u};function m(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"refs"},"Refs"),(0,i.kt)("h2",{id:"purpose"},"Purpose"),(0,i.kt)("p",null,"Unlike frameworks like React DOM or vanilla JavaScript, the is no way to modify the DOM elements in\nMini Program. But there is still some cases that developers need to access the instance of a\nspecific element. For example,\n",(0,i.kt)("a",{parentName:"p",href:"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createIntersectionObserver.html"},"wx.createIntersectionObserver"),"\nAPI return an observe that could watch the page scrolling and trigger when the intersection of a\ntarget element changed."),(0,i.kt)("h2",{id:"refs-1"},"Refs"),(0,i.kt)("p",null,"Because GojiJS use React components rather than Mini Program\n",(0,i.kt)("a",{parentName:"p",href:"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/"},"custom components"),",\nan elements might be rendered in the top of page or inside a custom component according to different\nruntime."),(0,i.kt)("p",null,"For example, this case on WeChat the ",(0,i.kt)("inlineCode",{parentName:"p"},"view-a")," rendered in the page and the ",(0,i.kt)("inlineCode",{parentName:"p"},"view-b")," rendered inside\n",(0,i.kt)("inlineCode",{parentName:"p"},"Subtree")," component."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"Subtree")," is a special built-in component that tell GojiJS to render its children in another\ncustom component. It works like ",(0,i.kt)("inlineCode",{parentName:"p"},"Fragment")," on non-WeChat platforms.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'const Comp = () => {\n  const refA = useRef<GojiPublicInstance | null>();\n  const refB = useRef<GojiPublicInstance | null>();\n  return (\n    <View className="view-a" ref={refA}>\n      <Subtree>\n        <View className="view-b" ref={refB}>\n          hi\n        </View>\n      </Subtree>\n    </View>\n  );\n};\nrender(<Comp />);\n')),(0,i.kt)("p",null,"So we should use ",(0,i.kt)("inlineCode",{parentName:"p"},"refA")," to observe the ",(0,i.kt)("inlineCode",{parentName:"p"},"view-a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"refB")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"view-b"),"."),(0,i.kt)("h2",{id:"userenderedeffect"},(0,i.kt)("inlineCode",{parentName:"h2"},"useRenderedEffect")),(0,i.kt)("p",null,"There is a main difference between Mini Programs and Web Apps, it is all DOMs modifications are\nasync applied. The second argument of\n",(0,i.kt)("a",{parentName:"p",href:"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#Page-prototype-setData-Object-data-Function-callback"},"setData"),"\nis a callback that run every time DOMs changes done."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"useRenderedEffect")," works as same as the ",(0,i.kt)("inlineCode",{parentName:"p"},"setData"),"'s callback. This hook runs after it make sure the\nDOMs are ready to observe. It's the earliest time to access the refs. If you use refs inside\n",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"ref.current")," might be ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.kt)("p",null,"Please remember we recommend to use ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," in any time only except using refs."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"Here is a full example."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"getComponentInstance")," returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," instance of which custom component that rendered inside."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"getComponentInstance")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," if the element was rendered on page."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, { useRef } from 'react';\nimport { View, useRenderedEffect, GojiPublicInstance } from '@goji/core';\n\nconst Comp = () => {\n  const viewRef = useRef<GojiPublicInstance | null>();\n  useRenderedEffect(() => {\n    const init = async () => {\n      if (viewRef.current) {\n        const componentInstance = await viewRef.current.getComponentInstance();\n        const observe = componentInstance\n          ? componentInstance.createIntersectionObserver()\n          : wx.createIntersectionObserver();\n        observer.relativeToViewport(...);\n      }\n    };\n\n    init();\n  }, []);\n\n  return <View ref={viewRef}>hello, world!</View>;\n};\n")))}m.isMDXComponent=!0},876:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var r=t(2784);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(t),m=o,f=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return t?r.createElement(f,a(a({ref:n},p),{},{components:t})):r.createElement(f,a({ref:n},p))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=d;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);